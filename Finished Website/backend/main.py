import os
from flask import Flask, request, jsonify
from flask_cors import CORS
from typing import Optional

from Crypto.Cipher import AES #the encryption algorithm we're using
from Crypto.Random import get_random_bytes #to make a random IV
from Crypto.Util.Padding import pad, unpad #to make sure the text fits the encryption block size
import base64
import binascii # to convert encrypted data to text formats (base64/hex)

import hashlib # For stream cipher key derivation

class BlockCipher:
    """Handles Block Cipher operations (AES in CBC mode)."""

    @staticmethod
    def encrypt(plaintext: str, key: str) -> dict[str, str]:
        """Encrypts plaintext using AES in CBC mode and returns Hex and Base64 encoded ciphertext."""
        # Ensure key is 32 bytes (256 bits)
        key_bytes = key.encode('utf-8')[:32].ljust(32, b'\0')

        # Generate a random Initialization Vector (IV)
        iv = get_random_bytes(16)

        # Create AES cipher object in CBC mode
        cipher = AES.new(key_bytes, AES.MODE_CBC, iv)

        # Pad the plaintext to be a multiple of the block size
        padded_plaintext = pad(plaintext.encode('utf-8'), AES.block_size)

        # Encrypt the padded plaintext
        encrypted_data = cipher.encrypt(padded_plaintext)

        # Combine IV and encrypted data for storage
        combined_data = iv + encrypted_data

        # Return Hex and Base64 encoded combined data
        return {
            "hex": binascii.hexlify(combined_data).decode('utf-8'),
            "base64": base64.b64encode(combined_data).decode('utf-8')
        }

    @staticmethod
    def decrypt(ciphertext: str, key: str, format: str) -> Optional[str]:
        """Decrypts Base64 encoded ciphertext using AES in CBC mode and returns plaintext."""
        try:
            # Ensure key is 32 bytes (256 bits)
            key_bytes = key.encode('utf-8')[:32].ljust(32, b'\0')

            combined_data = binascii.unhexlify(ciphertext) if format.lower() == 'hex' else base64.b64decode(ciphertext)
            # Decode the Base64 ciphertext
            # combined_data = base64.b64decode(ciphertext)

            # Extract IV and encrypted data
            iv = combined_data[:16]
            encrypted_data = combined_data[16:]

            # Create AES cipher object using the same key and IV
            cipher = AES.new(key_bytes, AES.MODE_CBC, iv)

            # Decrypt the data and unpad
            decrypted_padded_data = cipher.decrypt(encrypted_data)
            plaintext_bytes = unpad(decrypted_padded_data, AES.block_size)

            # Return the decrypted plaintext
            return plaintext_bytes.decode('utf-8')
        except Exception:
            # Handle decryption errors (e.g., incorrect key, corrupted ciphertext)
            return None

class StreamCipher:
    """Handles Stream Cipher operations using a keystream generated by PBKDF2-HMAC."""

    @staticmethod
    def _key_stream_generator(key: str, length: int, salt: bytes = b'stream_salt') -> bytes:
        """Securely generates a deterministic keystream using PBKDF2-HMAC."""
        key_bytes = hashlib.pbkdf2_hmac(
            hash_name='sha256',
            password=key.encode(),
            salt=salt,
            iterations=100_000,
            dklen=length
        )
        return key_bytes

    @staticmethod
    def encrypt(plain_text: str, key: str) -> dict[str, str]:
        """Encrypts plaintext using a keystream and returns Hex and Base64 encoded ciphertext."""
        plain_bytes = plain_text.encode('utf-8')
        # Generate a keystream of the same length as the plaintext
        keystream = StreamCipher._key_stream_generator(key, len(plain_bytes))
        # XOR plaintext bytes with keystream bytes
        cipher_bytes = bytes([b ^ k for b, k in zip(plain_bytes, keystream)])
        # Return Base64 encoded ciphertext
        return {
            "hex": binascii.hexlify(cipher_bytes).decode('utf-8'),
            "base64": base64.b64encode(cipher_bytes).decode('utf-8')
        }
    @staticmethod
    def decrypt(ciphertext: str, key: str, format: str) -> Optional[str]:
        """Decrypts Base64 encoded ciphertext using a keystream and returns plaintext."""
        try:
            # Decode ciphertext based on format
            cipher_bytes = binascii.unhexlify(ciphertext) if format.lower() == 'hex' else base64.b64decode(ciphertext)
            # Generate a keystream of the same length as the decoded ciphertext
            keystream = StreamCipher._key_stream_generator(key, len(cipher_bytes))
            # XOR ciphertext bytes with keystream bytes
            plain_bytes = bytes([b ^ k for b, k in zip(cipher_bytes, keystream)])
            # Return the decrypted plaintext
            return plain_bytes.decode('utf-8')
        except Exception:
            # Handle decryption errors (e.g., incorrect key, corrupted ciphertext)
            return None

app = Flask(__name__)
CORS(app) # Enable CORS for all routes

@app.route("/")
def hello_world():
  """Example Hello World route."""
  name = os.environ.get("NAME", "World")
  return f"Hello {name}!"

@app.route('/api/encrypt/block', methods=['POST'])
def encrypt_block_api():
    data = request.get_json()
    """Endpoint for encrypting plaintext using Block Cipher."""
    if not data:
        return jsonify({"error": "Invalid JSON payload"}), 400

    plaintext = data.get('plaintext')
    key = data.get('key')

    if not isinstance(plaintext, str) or not plaintext:
        return jsonify({"error": "Invalid or missing 'plaintext'"}), 400
    if not isinstance(key, str) or not key:
        return jsonify({"error": "Invalid or missing 'key'"}), 400

    ciphertext = BlockCipher.encrypt(plaintext, key)
    return jsonify({"ciphertext": ciphertext}), 200

@app.route('/api/decrypt/block', methods=['POST'])
def decrypt_block_api():
    data = request.get_json()
    """Endpoint for decrypting ciphertext using Block Cipher."""
    if not data:
        return jsonify({"error": "Invalid JSON payload"}), 400

    ciphertext = data.get('ciphertext')
    key = data.get('key')
    format = data.get('format') # Get the format from the JSON data

    if not isinstance(ciphertext, str) or not ciphertext:
        return jsonify({"error": "Invalid or missing 'ciphertext'"}), 400
    if not isinstance(key, str) or not key:
        return jsonify({"error": "Invalid or missing 'key'"}), 400

    format = data.get('format') # Get the format from the JSON data

    if format not in ['hex', 'base64']: # Validate the format
        return jsonify({"error": "Invalid or missing 'format'. Must be 'hex' or 'base64'"}), 400
    plaintext = BlockCipher.decrypt(ciphertext, key, format) # Pass the format to the decrypt function
    if plaintext is None:
        return jsonify({"error": "Decryption failed. Check key, ciphertext, and format."}), 400

    return jsonify({"plaintext": plaintext}), 200

@app.route('/api/encrypt/stream', methods=['POST'])
def encrypt_stream_api():
    data = request.get_json()
    """Endpoint for encrypting plaintext using Stream Cipher."""
    if not data:
        return jsonify({"error": "Invalid JSON payload"}), 400

    plaintext = data.get('plaintext')
    key = data.get('key')

    if not isinstance(plaintext, str) or not plaintext:
        return jsonify({"error": "Invalid or missing 'plaintext'"}), 400
    if not isinstance(key, str) or not key:
        return jsonify({"error": "Invalid or missing 'key'"}), 400

    ciphertext = StreamCipher.encrypt(plaintext, key)
    return jsonify({"ciphertext": ciphertext}), 200

@app.route('/api/decrypt/stream', methods=['POST'])
def decrypt_stream_api():
    """Endpoint for decrypting ciphertext using Stream Cipher."""
    data = request.get_json()
    if not data:
        return jsonify({"error": "Invalid JSON payload"}), 400

    ciphertext = data.get('ciphertext')
    key = data.get('key')
    format = data.get('format')  # Get the format from the JSON data
    
    if not isinstance(ciphertext, str) or not ciphertext:
        return jsonify({"error": "Invalid or missing 'ciphertext'"}), 400
    if not isinstance(key, str) or not key:
        return jsonify({"error": "Invalid or missing 'key'"}), 400
    if format not in ['hex', 'base64']:  # Validate the format
        return jsonify({"error": "Invalid or missing 'format'. Must be 'hex' or 'base64'"}), 400

    plaintext = StreamCipher.decrypt(ciphertext, key, format)  # Pass the format to the decrypt function
    if plaintext is None:
        return jsonify({"error": "Decryption failed. Check key and ciphertext."}), 400

    return jsonify({"plaintext": plaintext}), 200

if __name__ == "__main__":
    app.run(debug=True, host="0.0.0.0", port=3000)